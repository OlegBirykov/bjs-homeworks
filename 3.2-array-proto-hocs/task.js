'use strict';

// Для лучшего усвоения материала буду подробно комментировать,
// чтобы потом использовать данный текст в качестве примера/учебного пособия
// Тема достаточно сложная, тонкости можно забыть очень быстро

// Флаг включает вывод в консоль отладочной информации, описанной в разделе "Критерии выполнения"
let debug = false;

// Просто функция задержки, приницип понятен
function sleep(milliseconds) {
  let e = new Date().getTime() + milliseconds;
  while (new Date().getTime() <= e) {}
}

function sum(...args) {
  sleep(100); // Задержка на 1/10 секунды
  /*
    reduce - cтандартный метод для массива, "свёртка" массива в число
    В данном случае результат свёртки - сумма элементов массива
    Первый аргумент метода - callback-функция, поочерёдно вызываемая для каждого элемента массива
    Второй аргумент (необязательный) - начальное значение результата перед началом перебора элементов. Если параметр не задан,
    в качестве начального значения должен браться первый элемент массива, а перебор начинаться со второго элемента,
    но проверять это здесь мы не будем
    При вызове в callback-функцию передаются четыре параметра:
    - результат вызова функции для предыдущего элемента, для первого элемента - начальное значение (второй аргумент метода)
    - значение текущего элемента массива
    - индекс текущего элемента массива
    - собственно массив (указатель на массив)
    В данном случае callback-функция использует только два первых параметра
    Имена параметров в области видимости функции задаются разработчиком функции, здесь это sum и arg
  */
  if (debug)// Информация для отладки
    console.log('Вызов функции');
  return args.reduce((sum, arg) => sum += +arg, 0); // +arg - унарный плюс, простейший способ преобразования в number, если аргументы имеют тип string
}

// То же, без задержки
function sumNoSleep(...args) {
  if (debug)
    console.log('Вызов функции');
  return args.reduce((sum, arg) => sum += +arg, 0);
}


function compareArrays(arr1, arr2) {
  // Проверка корректности входных параметров
  if ((!Array.isArray(arr1)) || (!Array.isArray(arr2)))
    throw new Error('Аргумент не является массивом'); 
  // Если массивы разной длины, сравнивать точно нет смысла
  if (arr1.length !== arr2.length) 
    return false;
  /* 
    Здесь тоже callback-функция, в которую передаются:
    - значение текущего элемента массива
    - индекс текущего элемента массива
    - собственно массив (указатель на массив)
    Используются первые два параметра
    Метод every суммирует по "И" результаты вызова функции для каждого элемента массива
  */
  return arr1.every((n, i) => n === arr2[i]);
}

function memorize(fn, limit) {
  /*
    В результате вызова данная функция возвратит ссылку на функцию mFn,
    к которой в дальнейшем можно будет обращаться из внешней области видимости.
    Во внешней области это будет объект, продолжающий своё существование после завершения
    вызова функции memorize. Так как функция mFn обращается к массиву memory, он тоже продолжит
    своё существование после завершения вызова функции memorize. Но при вызовах функции mFn
    заново инициализироваться он не будет, следовательно, может быть использован для хранения данных
    между вызовами этой функции. Так работает механизм замыкания, позволяющий создавать для функции 
    статические (не создаваемые заново при каждом вызове) переменные, при этом видимые только из самой этой функции.
  */
  const memory = [];
  
  function mFn(...args) { // Число аргументов здесь может быть любым
    if (debug) // Отладочная информация
      console.log(args);    
    // Попытаться найти в массиве запись с тем же самым набором аргументов
    // ... - оператор деструктуризации. Если args - это массив, то ...args - список его элементов 
    const record = memory.find(item => compareArrays(args, item.args));
    // Если получилось - вывести указанный в этой записи результат
    if (record !== undefined){
      if (debug) // Отладочная информация
        console.log('Результат из памяти');
      return record.result;
    }
    // Иначе вычислить результат
    const result = fn(...args); // Ещё можно вызвать функцию через метод fn.apply 
    //Добавить в memory новую запись    
    memory.push({ args, result });
    // Если число записей превысило лимит, удалить самую старую
    if (memory.length > limit)
      memory.shift();
    if (debug) // Отладочная информация 
      console.table(memory); // Структурные данные лучше выводить в виде таблицы      
    // Возвратить результат
    return result;
  } 
  
  // Вернуть указатель на вложенную функцию
  return mFn;
}

function testCase(testFunction, timerName) {
  // Наборы аргументов для тестирования функции
  const testArgs = [
    [1,2,3], 
    [1,2], 
    [1,2,3], 
    [1,2], 
    [9,5,2,4],
    [1,2,3], 
    [1,2,3], 
    [3,2,3],
    [1,2,3], 
    [1,2,3], 
    [1,2,3], 
    [1,2,3], 
    [1,2,3], 
    [1,2,3], 
    [1,2,3], 
    [1,2,3], 
    [2,3],
    [2,4,5,8,123],
    [2,5],
    [2,6],
    [2,7],
    [2,8],
    [2,9],
    [2,10],
    [2,3,12]
  ];
  
  console.time(timerName); // Запустить таймер-счётчик с заданным именем
  
  //Провести тестовый цикл, в режиме отладки - однократный вызов
  for (let i = 0; i < (debug ? 1 : 10); i++)
    // Перебор элементов массива testArgs с вызовом callback функции. 
    // При вызове используется первый параметр - текущий элемент массива testArgs, т.е., массив чисел-аргументов
    testArgs.forEach(args => testFunction(...args));
  
  console.timeEnd(timerName); // Остановить таймер-счётчик с заданным именем
}


// Создать оптимизированные функции для тестирования
const mSum = memorize(sum,10);
const mSumNoSleep = memorize(sumNoSleep,10);

// Собственно, запуск тестов
testCase(sum,'тест 1-1');
testCase(mSum,'тест 1-2');
testCase(sumNoSleep,'тест 2-1');
testCase(mSumNoSleep,'тест 2-2');

/*
  Результаты тестирования:
  тест 1-1: 25250.3701171875ms
  тест 1-2: 13129.680908203125ms
  тест 2-1: 0.4609375ms
  тест 2-2: 1.275146484375ms  
  
  Вывод: если функция сложная и часто вызывается, а в наборе аргументов часто повторяются одни и те же 
  комбинации - имеет смысл её оптимизировать предложенным в задаче способом
  Если простая и выполняется быстро - не стоит, больше времени потеряем на оптимизацию  
*/

// Включить режим отладки
debug = true;

// И убедиться, что всё работает правильно
testCase(sum,'тест 3-1');
testCase(mSum,'тест 3-2');









